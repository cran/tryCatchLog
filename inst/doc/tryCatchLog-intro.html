<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>License (GPL-3)</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>For a slide version of this vignette (e. g. for trainings and presentations) see:</p>

<p><a href="https://aryoda.github.io/tutorials/tryCatchLog/tryCatchLog-intro-slides.html">https://aryoda.github.io/tutorials/tryCatchLog/tryCatchLog-intro-slides.html</a></p>

<h2>License (GPL-3)</h2>

<p><img src="data:image/png;base64,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" alt="gplv3 logo"/></p>

<p>Copyright &copy; 2016++ JÃ¼rgen Altfeld (<a href="mailto:R@altfeld-im.de">R@altfeld-im.de</a>)</p>

<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>

<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>

<p>You should have received <a href="https://github.com/aryoda/tryCatchLog/blob/master/LICENSE">a copy of the GNU General Public License</a>
along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>

<h2>Overview</h2>

<p>The <code>tryCatchLog</code> package provides an advanced <code>tryCatch</code> function for the programming language <a href="https://www.r-project.org/">R</a>.</p>

<p>The main advantages of the <code>tryCatchLog</code> function over <code>tryCatch</code> are:</p>

<ul>
<li><strong>Easy logging</strong> of errors, warnings and messages into a file or console</li>
<li><strong>Complete stack trace with references to the source file names and line numbers</strong>
to identify the source of errors and warnings
(R&#39;s <code>traceback</code> does not contain the full stack trace if you catch errors and warnings!)</li>
<li><strong><a href="#post-mortem-analysis">Post-mortem analysis</a> or R errors by creating a dump file</strong>
with all variables of the global environment (workspace) and the function call stack (<code>dump.frames</code>)
to enable the analysis of &ldquo;crashed&rdquo; batch jobs that you cannot debug on the server directly to reproduce the error!</li>
<li><strong>Logging</strong> of warnings (and other non-error conditions)
<strong>without stopping the execution</strong> of the evaluated expression
(unlike <code>tryCatch</code> does if you pass a warning handler function)</li>
</ul>

<h2>Table of contents</h2>

<p>Part 1: <code>tryCatch</code> in standard R</p>

<p><a href="#introduction-into-conditions-in-standard-r">Introduction into conditions in standard R</a><br/>
<a href="#throw-your-own-conditions">Throw your own conditions</a><br/>
<a href="#handling-conditions-in-r">Handling conditions in R</a><br/>
<a href="#the-drawbacks-of-trycatch">The drawbacks of tryCatch</a><br/>
<a href="#workaround-1-interactive-debugging">Workaround 1: Interactive debugging</a><br/>
<a href="#workaround-2-withcallinghandlers-trycatch">Workaround 2: withCallingHandlers + tryCatch</a>  </p>

<p>Part 2: Package <code>tryCatchLog</code></p>

<p><a href="#better-error-handling-with-the-trycatchlog-package">Better error handling with the tryCatchLog package</a><br/>
<a href="#post-mortem-analysis">Post-mortem analysis</a><br/>
<a href="#trycatchlog-function-reference">tryCatchLog Function Reference</a><br/>
<a href="#trycatchlog-best-practices">tryCatchLog Best Practices</a>  </p>

<p><a href="#appendix">Appendix</a></p>

<h1>Introduction into conditions in standard R</h1>

<h2>What is a condition?</h2>

<p>The execution of an R script can be interrupted to signal special states (<em>conditions</em>) like:</p>

<ul>
<li>errors</li>
<li>warnings</li>
<li>info messages</li>
<li>user requested interrupts (by hitting CTRL + C/BRK or ESC)</li>
</ul>

<p>For details see the R help:   <code>?conditions</code></p>

<h2>Condition examples</h2>

<p>An error condition:</p>

<pre><code class="r">log(&quot;text&quot;)   # calculating the logarithm of a string throws an error
</code></pre>

<pre><code>## Error in log(&quot;text&quot;): non-numeric argument to mathematical function
</code></pre>

<p>A warning condition:</p>

<pre><code class="r">log(-1)                # logarithm of a negative number throws a warning
</code></pre>

<pre><code>## Warning in log(-1): NaNs produced
</code></pre>

<pre><code>## [1] NaN
</code></pre>

<h1>Throw your own conditions</h1>

<p>Note: This text will never be shown due to a &ldquo;limitation by design&rdquo; of pandoc:</p>

<p><a href="http://stackoverflow.com/a/31778080/4468078">http://stackoverflow.com/a/31778080/4468078</a></p>

<h2>Throw an Error</h2>

<p>Use <code>stop</code> to throw an error &ldquo;condition&rdquo; to signal an invalid program state:</p>

<pre><code class="r">if (1 != 2)
  stop(&quot;something is wrong&quot;)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): something is wrong
</code></pre>

<p></br>
Or shorter (but without a way to specify an error text):</p>

<pre><code class="r">stopifnot(1 == 2)
</code></pre>

<pre><code>## Error: 1 == 2 is not TRUE
</code></pre>

<p><code>stopifnot</code> is quite often used to ensure pre-conditions in function calls.</p>

<h2>Throw a Warning</h2>

<pre><code class="r">warning(&quot;bad weather today, don&#39;t forget your umbrella&quot;)
</code></pre>

<pre><code>## Warning: bad weather today, don&#39;t forget your umbrella
</code></pre>

<h2>Throw a Message</h2>

<pre><code class="r">message(&quot;good morning&quot;)
</code></pre>

<pre><code>## good morning
</code></pre>

<h1>Handling conditions in R</h1>

<p>Scroll down for examples&hellip;</p>

<h2>Unhandled errors stop R</h2>

<p>By default R will stop the execution if an error occurs:</p>

<pre><code class="r">options(error = NULL)  # switch to default behaviour of pure R

test &lt;- function() {
  log(&quot;not a number&quot;)
  print(&quot;R does stop due to an error and never executes this line&quot;)
}

test()     # throws an error
</code></pre>

<pre><code>## Error in log(&quot;not a number&quot;): non-numeric argument to mathematical function
</code></pre>

<p>Note that the output does <strong>not</strong> show the <code>print</code> result since the execution stops in case of an error.</p>

<h2>Use <code>try</code> to ignore errors</h2>

<p>With the <code>try</code> function you can handle errors to continue the execution (by ignoring the error):</p>

<pre><code class="r">try(log(&quot;not a number&quot;), silent = TRUE)
print(&quot;errors can&#39;t stop me&quot;)
</code></pre>

<pre><code>## [1] &quot;errors can&#39;t stop me&quot;
</code></pre>

<p><strong>Note:</strong> If an error occurs then the error message is printed to the <code>stderr</code> connection
unless the call includes <code>silent = TRUE</code>.</p>

<h2>Use <code>tryCatch</code> to handle errors</h2>

<p>With <code>tryCatch</code> you can handle errors as you want:</p>

<pre><code class="r">an.error.occured &lt;- FALSE
tryCatch( { result &lt;- log(&quot;not a number&quot;); print(res) }
          , error = function(e) {an.error.occured &lt;&lt;- TRUE})
print(an.error.occured)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p></br>
If you use an error handler function</p>

<ul>
<li>the error is not shown anymore and</li>
<li>the execution continues after the <code>tryCatch</code> statement.</li>
</ul>

<h2><code>tryCatch</code> can handle all conditions &frac12;</h2>

<p>&hellip; not only errors. Just use the condition name as parameter to handle conditions of this type, e. g. warnings:</p>

<pre><code class="r">tryCatch( { result &lt;- log(-1); print(result) }
          , warning = function(w) { print(&quot;Hey, a warning&quot;) })
</code></pre>

<pre><code>## [1] &quot;Hey, a warning&quot;
</code></pre>

<h2><code>tryCatch</code> can handle all conditions 2/2</h2>

<p>You can use <code>error</code>, <code>warning</code>, <code>message</code> or <code>interrupt</code> as parameter name to assign a handler for these &ldquo;standard&rdquo; conditions, e. g. to catch messages:</p>

<pre><code class="r">last.message &lt;- NULL
tryCatch( { message(&quot;please handle me&quot;); print(&quot;Done&quot;) }
          , message = function(m) { last.message &lt;&lt;- m })
print(last.message$message)
</code></pre>

<pre><code>## [1] &quot;please handle me\n&quot;
</code></pre>

<h2>Advanced topic: User defined conditions</h2>

<p>You can even define your own user-defined condition classes, but
there is no built-in function to generate a new object of class <code>condition</code>.
So do it yourself:*</p>

<pre><code class="r">condition &lt;- function(subclass, message, call = sys.call(-1), ...) {
  structure( class = c(subclass, &quot;condition&quot;),
             list(message = message, call = call, ...))
}

tryCatch( { work &lt;- condition(&quot;my.work.condition&quot;, &quot;after work party&quot;)
            signalCondition(work); print(&quot;Done&quot;) }
          , my.work.condition = function(c) { print(c$message) })
</code></pre>

<pre><code>## [1] &quot;after work party&quot;
</code></pre>

<p>User-defined condition classes are only required if you want to implement a specific recovery strategy for
this condition. This is out of scope of this presentation.</p>

<p>*) Source: <a href="http://adv-r.had.co.nz/beyond-exception-handling.html">http://adv-r.had.co.nz/beyond-exception-handling.html</a></p>

<h2>But <code>tryCatch</code> is not perfect</h2>

<p>Have you discovered the problem in the previous examples?</p>

<p>See the next chapter for the answer!</p>

<h1>The drawbacks of <code>tryCatch</code></h1>

<h2>Handling a condition stops the execution &frac12;</h2>

<p>Calling the function <strong>without</strong> a <code>tryCatch</code> handler does <strong>not stop</strong> the
execution of the function <code>f()</code>:</p>

<pre><code class="r">{ # required to execute the code as one block to summarize the output in this Rmd
  f &lt;- function() {
    warning(&quot;deprecated function called&quot;)
    print(&quot;Hello world&quot;)
  }
  f()
  print(&quot;Done&quot;)
}
</code></pre>

<pre><code>## Warning in f(): deprecated function called
</code></pre>

<pre><code>## [1] &quot;Hello world&quot;
## [1] &quot;Done&quot;
</code></pre>

<p>but&hellip;</p>

<h2>Handling a condition stops the execution 2/2</h2>

<p>Handling a condition <strong>cancels</strong> the execution of the code block that raised (throwed) the condition:</p>

<pre><code class="r">f &lt;- function() {
  warning(&quot;deprecated function called&quot;)
  print(&quot;Hello world&quot;)
}
tryCatch(f(), warning = function(w) { write.to.log(w) })
print(&quot;Done&quot;)
</code></pre>

<pre><code>## [1] &quot;Done&quot;
</code></pre>

<p><strong>Observe:</strong> <em>Hello world</em> is never printed just because we catched a warning!</p>

<p><strong>If you catch a condition with <code>tryCatch</code> (even just a warning or message) then R</strong></p>

<ol>
<li>executes the condition handler function</li>
<li>aborts the execution of the code block that throwed the condition</li>
<li>continues the execution with <strong>the next command after the <code>tryCatch</code> command</strong></li>
</ol>

<h2>Handling errors unrolls the stack trace &frac12;</h2>

<p>If you do <strong>not catch an error</strong> R stops and you can get the complete function call stack using <code>traceback</code>
to identify the code that throwed the error:</p>

<pre><code class="r">options(error=function() traceback(2)) # http://stackoverflow.com/a/13119318/4468078
f &lt;- function() {
  log(&quot;not a number&quot;)
  print(&quot;Hello world&quot;)
}
f()
</code></pre>

<pre><code class="r">Error in log(&quot;not a number&quot;) :
  non-numeric argument to mathematical function
6: (function ()
   traceback(2))() at f.R#3
5: f() at f.R#6
...
1: source(&quot;f.R&quot;)
</code></pre>

<p><strong>Note:</strong> The call stack shows the line number after the file name and hash sign, e. g. <code>file1.R#7</code> = line number 7</p>

<h2>Handling errors unrolls the stack trace 2/2</h2>

<p>But if you handle the error, the call stack is truncated:</p>

<pre><code class="r">f &lt;- function() {
  log(&quot;not a number&quot;)
  print(&quot;Hello world&quot;)
}
tryCatch(f(), error = function(e) { traceback() })
</code></pre>

<pre><code class="r">8: value[[3L]](cond)
7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
6: tryCatchList(expr, classes, parentenv, handlers)
5: tryCatch(f(), error = function(e) {
       traceback(2)
   }) at f.R#5
...
1: source(&quot;f.R&quot;)
</code></pre>

<p>The call stack ends basically with the <code>tryCatch</code> call but <strong>does not show you the code line in <code>f()</code>
where the error was thrown</strong>.</p>

<h2>Summary: The drawbacks of <code>tryCatch</code></h2>

<ol>
<li><p><strong>You can not find out the exact reason for errors</strong> because the full stack trace is truncated</p></li>
<li><p>Handling of warnings and messages (e. g. just to log them) cancels
the execution of the code block that throwed the condition (what is unexpected!)</p></li>
</ol>

<p>See the next chapters for possible work-arounds&hellip;</p>

<h1>Workaround 1: Interactive debugging</h1>

<h2>Interactive debugging</h2>

<p>You can run and debug your R script interactively in the <em>RGui</em> or <a href="https://www.rstudio.com/products/rstudio/">RStudio</a>
instead of condition handling with <code>tryCatch</code>.</p>

<p>For more details on interactive debugging see <code>?debug</code>.</p>

<p><strong>Note: Interactive debugging is out of scope of this presentation.</strong></p>

<h2>Limitations of interactive debugging</h2>

<p>Interactive debugging is very difficult in case of</p>

<ul>
<li>errors that are not (easily) reproducible.</li>
<li>errors that occur only after a long run time</li>
<li>batch jobs running on a server (you have no interactive GUI then!)</li>
</ul>

<h1>Workaround 2: <code>withCallingHandlers</code> + <code>tryCatch</code></h1>

<h2>How <code>withCallingHandlers</code> works</h2>

<p><code>withCallingHandlers</code> works similar to <code>tryCatch</code> but</p>

<ol>
<li>remembers the call stack down to the point where the condition was signaled</li>
<li>resumes the execution after the point where the condition was signaled</li>
</ol>

<pre><code class="r">f &lt;- function() {
  warning(&quot;deprecated function called&quot;)
  print(&quot;Hello world&quot;)
}
withCallingHandlers(f(), warning = function(w) { write.to.log(sys.calls()) })
</code></pre>

<pre><code>## Warning in f(): deprecated function called
</code></pre>

<pre><code>## [1] &quot;Hello world&quot;
</code></pre>

<p><strong>Note:</strong> Use <strong><code>sys.calls</code>** within <code>withCallingHandlers</code> to return the full **call stack</strong>.</p>

<h2><code>withCallingHandlers</code> supports restarts</h2>

<p><em>Restarts</em> allow to recover from conditions using a predefined behaviour:</p>

<pre><code class="r">f &lt;- function() {
  warning(&quot;deprecated function called&quot;)
  print(&quot;Hello old world&quot;)
}
withCallingHandlers(f(), warning = function(w) { write.to.log(sys.calls())
                                                 invokeRestart(&quot;muffleWarning&quot;)})
print(&quot;Done&quot;)
</code></pre>

<pre><code>## [1] &quot;Hello old world&quot;
## [1] &quot;Done&quot;
</code></pre>

<p><code>invokeRestart(&quot;muffleWarning&quot;)</code> has a simple recovery strategy: &ldquo;Suppress the warning&rdquo;.</p>

<p>It consumes the warning (so it does not &ldquo;bubble up&rdquo; to higher function call levels)
and resumes the execution.</p>

<p><em>TODO: Mention other restarts and their behaviour&hellip;</em></p>

<h2>Differences between <code>withCallingHandlers</code> and <code>tryCatch</code></h2>

<table><thead>
<tr>
<th></th>
<th>tryCatch</th>
<th>withCallingHandlers</th>
</tr>
</thead><tbody>
<tr>
<td><strong>Program execution</strong></td>
<td><strong>breaks</strong> and continues with the first expression after the <code>tryCatch</code> function call</td>
<td><strong>resumes</strong> the execution at the code line that throwed the condition</td>
</tr>
<tr>
<td><strong>Call stack</strong> (<code>traceback</code> and <code>sys.calls</code>)</td>
<td><strong>unwinds the call stack</strong> up to the <code>tryCatch</code> function call</td>
<td><strong>keeps the full call stack</strong> down to the code line that throwed the condition</td>
</tr>
<tr>
<td><strong>Rethrowing of conditions</strong></td>
<td><strong>Conditions are consumed</strong> by the called handler function (do not bubble up)</td>
<td><strong>Conditions bubble up</strong> (are not consumed by the called handler function)</td>
</tr>
</tbody></table>

<p><strong>Note: <code>tryCatch</code> is different from Java&#39;s <code>try-catch</code> statement: It unwinds the call stack (in Java you get the
full call stack with the <code>printStackTrace</code> method)!</strong></p>

<h2>Combine <code>withCallingHandlers</code> with <code>tryCatch</code></h2>

<p>The requirements for better condition handling in R are:</p>

<ul>
<li>Get the full call stack for all catched conditions</li>
<li>Resume execution after handling warnings and messages</li>
<li>Catch errors and continue the execution after the handler function</li>
</ul>

<p>Solution:</p>

<ul>
<li>Handle all conditions in <code>withCallingHandlers</code> to log them with the full stack trace</li>
<li>Invoke a restart in <code>withCallingHandlers</code> to resume after a non-error condition</li>
<li>Handle only errors in <code>tryCatch</code> to recover from the error and continue execution after the <code>tryCatch</code> function call</li>
</ul>

<h2>Code snippet for better error handling</h2>

<p>An improved &ldquo;error handler&rdquo; in R looks similar to this code snippet:</p>

<pre><code class="r">f &lt;- function() {
  warning(&quot;deprecated function called&quot;)
  print(&quot;A warning cannot stop me&quot;)
  log(&quot;not a number&quot;)
  print(&quot;Hello old world&quot;)
}

tryCatch(withCallingHandlers(f(), error=function(e) {write.to.log(sys.calls())}
                                , warning=function(w) {write.to.log(sys.calls())
                                                invokeRestart(&quot;muffleWarning&quot;)})
         , error = function(e) { print(&quot;recovered from error&quot;) })
print(&quot;Done&quot;)
</code></pre>

<pre><code>## [1] &quot;A warning cannot stop me&quot;
## [1] &quot;recovered from error&quot;
## [1] &quot;Done&quot;
</code></pre>

<p><strong>This is basically how the <code>tryCatchLog</code> package works internally!</strong></p>

<h2>How about usability?</h2>

<p><strong>Do you really want to use that much boilerplate code in your R scripts at every place
where you have to catch errors and conditions?</strong></p>

<p>If not: See the the next chapter to learn how the package <code>tryCatchLog</code> could make your life much easier!</p>

<h1>Better error handling with the <code>tryCatchLog</code> package</h1>

<h2>Installation</h2>

<p>To install the package <code>tryCatchLog</code> from the source code use:</p>

<pre><code class="r"># install.packages(&quot;devtools&quot;)
library(devtools)
install_github(&quot;aryoda/tryCatchLog&quot;)
</code></pre>

<p>For more details see the Project site at: <a href="https://github.com/aryoda/tryCatchLog">https://github.com/aryoda/tryCatchLog</a></p>

<h2>Overview</h2>

<p>The <code>tryCatchLog</code> package improves the standard R&#39;s <code>try</code> and <code>tryCatch</code> functions by
offering extended functions:</p>

<table><thead>
<tr>
<th>Condition handling strategy</th>
<th>Standard R</th>
<th>tryCatchLog package</th>
</tr>
</thead><tbody>
<tr>
<td>Return an error object in case of errors</td>
<td><code>try()</code></td>
<td><code>tryLog()</code></td>
</tr>
<tr>
<td>Call condition handler functions</td>
<td><code>tryCatch()</code></td>
<td><code>tryCatchLog()</code></td>
</tr>
</tbody></table>

<p><strong>Improvements:</strong></p>

<ol>
<li>Configurable <strong>logging</strong> (&ldquo;for free&rdquo;)</li>
<li>Logging of full or compact <strong>call stack</strong> with line numbers</li>
<li><strong>Resume</strong> after warnings and messages</li>
<li>Support for <strong>post-mortem analysis</strong> after errors via dump files</li>
</ol>

<h2><code>tryLog</code> example with an error</h2>

<p>Errors are logged but the execution continues after the <code>tryLog</code> call:</p>

<pre><code class="r">library(tryCatchLog)
f &lt;- function(value) {
  print(&quot;begin&quot;)
  log(value)            # negative number -&gt; warning; string -&gt; error
  print(&quot;end&quot;)
}
tryLog(f(&quot;not a number&quot;))
print(&quot;Errors don&#39;t stop me!&quot;)
</code></pre>

<pre><code class="r">## [1] &quot;begin&quot;
## ERROR [2016-12-06 21:44:21] non-numeric argument to mathematical function
## Compact call stack:
##   1 test.R#7: tryLog(f(&quot;not a number&quot;))
##   2 tryCatchLog.R#345: tryCatchLog(expr = expr, write.error.dump.file = write.error.dump.file, error = function(e) {
##   3 tryCatchLog.R#259: tryCatch(withCallingHandlers(expr, error = function(e) {
##   4 test.R#4: .handleSimpleError(function (e)
## ...
## [1] &quot;Errors don&#39;t stop me!&quot;
</code></pre>

<h2><code>tryLog</code> example with a warning</h2>

<p><code>tryLog</code> catches conditions and logs them onto console or into a file (depending of the settings of
the logging framework <code>futile.logger</code> that is used internally):</p>

<pre><code class="r">library(tryCatchLog)
f &lt;- function(value) {
  print(&quot;begin&quot;)
  log(value)            # negative number -&gt; warning; string -&gt; error
  print(&quot;end&quot;)
}
tryLog(f(-1))
</code></pre>

<pre><code class="r">## [1] &quot;begin&quot;
## WARN [2016-12-06 21:33:41] NaNs produced
## Compact call stack:
##   1 test.R#7: tryLog(f(-1))
##   2 tryCatchLog.R#345: tryCatchLog(expr = expr, write.error.dump.file = write.error.dump.file, error = function(e) {
##   3 tryCatchLog.R#259: tryCatch(withCallingHandlers(expr, error = function(e) {
##   4 test.R#4: .signalSimpleWarning(&quot;NaNs produced&quot;, quote(log(value)))
...
## [1] &quot;end&quot;
</code></pre>

<h2><code>tryCatchLog</code> example to log and recover from an error</h2>

<p>Use <code>tryCatchLog</code> to establish an error handler:</p>

<pre><code class="r">library(tryCatchLog)

send.email &lt;- function(receiver, body) { }  # dummy function (does nothing)

tryCatchLog(log(&quot;not a number&quot;),
            error = function(e) { send.email(&quot;admin@home&quot;, e)
            })
</code></pre>

<p>The console shows the log output then and the execution continues:</p>

<pre><code class="r">ERROR [2017-01-22 22:04:56] non-numeric argument to mathematical function
Compact call stack:
  1 tryCatchLog_error_example.R#5: tryCatchLog(log(&quot;not a number&quot;), error = function(e) {
  2 tryCatchLog.R#273: tryCatch(withCallingHandlers(expr, error = function(e) {
...
</code></pre>

<p><strong>Note:</strong> <code>send.email</code> is a dummy function for demonstration purposes!</p>

<h2>How to change the logging behaviour</h2>

<p>To log to a file instead of the console or to change the logging level you call the usual <code>futile.logger</code> functions:</p>

<pre><code class="r">  library(futile.logger)

  flog.appender(appender.file(&quot;app.log&quot;))

  flog.threshold(ERROR)    # TRACE, DEBUG, INFO, WARN, ERROR, FATAL

  try(log(-1))             # the warning will not be logged!
</code></pre>

<p>For more details about <code>futile.logger</code> see:</p>

<p><a href="https://cran.r-project.org/package=futile.logger">https://cran.r-project.org/package=futile.logger</a></p>

<h1>Post-mortem analysis</h1>

<h2>Known limitations of interactive debugging in R</h2>

<p>Interactive debugging using an IDE or the console is very difficult in case of</p>

<ul>
<li>errors that are not (easily) reproducible</li>
<li>long running code that produces an error at the end</li>
<li>batch jobs running on a server</li>
</ul>

<h2>Solution: Post-mortem analysis</h2>

<p><strong>Post-mortem analysis</strong> means to create a dump file in case of an error that contains</p>

<ul>
<li>all objects of the global environment (workspace) and</li>
<li>all objects within the scope of each called function (via <code>dump.frames</code>)</li>
</ul>

<p>so that you can</p>

<ul>
<li>use any computer</li>
<li>to load the dump file into a new R session</li>
<li>after the script has stopped the execution (<strong>&ldquo;post-mortem&rdquo;</strong>) and</li>
<li>examine the call stack and object values (&ldquo;analysis&rdquo;)</li>
</ul>

<p>to find out the reason for the error.</p>

<h2>Enable post-mortem analysis</h2>

<p><code>tryCatchLog</code> supports post-mortem analysis by creating dump files in case of errors:</p>

<pre><code class="r">library(tryCatchLog)
f &lt;- function(value) {
  log(value)
}
a &lt;- &quot;100&quot;
tryLog(f(a), write.error.dump.file = TRUE)
</code></pre>

<pre><code class="r">ERROR [2016-12-12 22:29:52] non-numeric argument to mathematical function
Call stack environments dumped into file: dump_20161212_222952.rda
Compact call stack:
  1 source(&quot;~/R_trainings/tryCatchLog/src/test.R&quot;)
  2 test.R#6: tryLog(f(a), write.error.dump.file = TRUE)
  3 tryCatchLog.R#348: tryCatchLog(expr = expr, write.error.dump.file = write.error.dump.file, error = function(e) {
  4 tryCatchLog.R#262: tryCatch(withCallingHandlers(expr, error = function(e) {
  5 test.R#3: .handleSimpleError(function (e)
  ...
</code></pre>

<h2>Start a post-mortem analysis</h2>

<p>Open a new R session and start the post-mortem analysis of the error:</p>

<pre><code class="r">load(&quot;dump_20161212_222952.rda&quot;)    # load the dump into the global environment
debugger(last.dump)                 # start the post-mortem analysis
</code></pre>

<pre><code class="r">Message:  non-numeric argument to mathematical functionAvailable environments had calls:
1: source(&quot;test.R&quot;)
...
5: test.R#6: tryLog(f(a), write.error.dump.file = TRUE)
6: tryCatchLog.R#348: tryCatchLog(expr = expr, write.error.dump.file = dump.erro
7: tryCatchLog.R#262: tryCatch(withCallingHandlers(expr, error = function(e) {
...
12: f(a)
13: test.R#3: .handleSimpleError(function (e)
14: h(simpleError(msg, call))

Enter an environment number, or 0 to exit
Selection: &lt;Cursor is waiting for your input here&gt;
</code></pre>

<p>The function call #13 shows: The error was thrown in the file <code>test.R</code> at line #3: <code>log(value)</code></p>

<h2>Post-mortem debugging: Examine an environment</h2>

<p>Switch into the environment of the function call #12 which called the function that throwed the error
and examine the objects visible within this function:</p>

<pre><code class="r">Enter an environment number, or 0 to exit
Selection: 12
Browsing in the environment with call:
   f(a)
Called from: debugger.look(ind)
Browse[1]&gt; ls()
[1] &quot;value&quot;
Browse[1]&gt; value
[1] &quot;100&quot;
Browse[1]&gt; typeof(value)
[1] &quot;character&quot;
Browse[1]&gt;
</code></pre>

<p>By looking at the (function argument) variable <code>value</code>
it is easy to identify the reason for the error: <strong>The passed value &ldquo;100&rdquo; had the wrong data type!</strong></p>

<p><em>You can exit the debugger now with &ldquo;Q&rdquo; (or &ldquo;f&rdquo; followed by &ldquo;0&rdquo;) and fix the bug.</em></p>

<h2>Post-mortem debugging: Limitations</h2>

<p>R dump files (created with <code>save.image</code>) do <strong>not</strong> contain the loaded packages
when the dump file was created.</p>

<p>Therefore a dump loaded into memory later does <strong>not</strong> load these packages automatically.</p>

<p><strong>This means the program state as of the error is not exactly reproducible:</strong></p>

<ul>
<li>Objects that were stored within a package namespace are not available</li>
<li>The search path to find objects may be different during post-mortem analysis</li>
<li>You cannot step through your source code after loading the image
if your source code calls functions of non-default packages. You have to load these packages manually
before starting the debugger</li>
</ul>

<p>For more details see: <a href="https://github.com/aryoda/tryCatchLog/issues/12">https://github.com/aryoda/tryCatchLog/issues/12</a></p>

<h1><code>tryCatchLog</code> Function Reference</h1>

<h2>tryCatchLog()</h2>

<p>Function signature:</p>

<pre><code class="r">tryCatchLog(expr, ..., finally = NULL,
  write.error.dump.file = getOption(&quot;tryCatchLog.write.error.dump.file&quot;, FALSE),
  silent.warnings       = getOption(&quot;tryCatchLog.silent.warnings&quot;, FALSE),
  silent.messages       = getOption(&quot;tryCatchLog.silent.messages&quot;, FALSE))
</code></pre>

<p>This function evaluates the expression in <code>expr</code> and passes all condition handlers in <code>...</code> to <code>tryCatch</code> as-is
while error, warning and message conditions are logged together with the function call stack
(including file names and line numbers).</p>

<p>The expression in <code>finally</code> is always evaluated at the end.</p>

<p>Warnings and messages can be &ldquo;silenced&rdquo; (only logged but not propagated to the caller) using the <code>silent.*</code> parameters.</p>

<p>The default values of some parameters can be set globally via <code>options</code> to avoid passing the same
parameter values in each call and to support easy reconfiguration for all calls without changing the code.</p>

<h2>tryLog()</h2>

<p>Function signature:</p>

<pre><code class="r">tryLog(expr,
  write.error.dump.file = getOption(&quot;tryCatchLog.write.error.dump.file&quot;, FALSE),
  silent.warnings       = getOption(&quot;tryCatchLog.silent.warnings&quot;, FALSE),
  silent.messages       = getOption(&quot;tryCatchLog.silent.messages&quot;, FALSE))
</code></pre>

<p>This function is a short version of <code>tryCatchLog()</code>
that traps any errors that occur during the evaluation of the expression <code>expr</code>
without stopping the execution of the script (similar to <code>try</code> in R).
Errors, warnings and messages are logged.</p>

<p>In contrast to <code>tryCatchLog()</code> it returns an object of the class &ldquo;try-error&rdquo;
in case of an error and continues after the <code>tryLog</code> expression.
Therefore <code>tryLog</code> does not support the <code>error</code> and <code>finally</code> parameters
for passing custom handler functions.</p>

<p>The default values of some parameters can be set globally via <code>options</code> to avoid passing the same
parameter values in each call and to support easy reconfiguration for all calls without changing the code.</p>

<h2>Change global options of <code>tryCatchLog</code></h2>

<p>The default values of many options can be changed globally by configuring them once
to reduce lengthy function calls later and support easy reconfiguration for all calls
without changing the code:</p>

<pre><code class="r"># Initialize your own default values globally for tryLog and tryCatchLog
options(tryCatchLog.write.error.dump.file = FALSE)
options(tryCatchLog.silent.messages       = TRUE)
options(tryCatchLog.silent.warnings       = TRUE)

test &lt;- function() {
  message(&quot;hello&quot;)
  warning(&quot;a warning&quot;)
}

# Use your own default values by ommiting those parameters...
tryLog(f())

# .. instead of the longer version which passes each parameter again and again
tryLog(f(), silent.warnings=TRUE, silent.messages=TRUE, write.error.dump.file=FALSE)
</code></pre>

<h1><code>tryCatchLog</code> Best Practices</h1>

<h2>Easiest way to add logging of all conditions</h2>

<p>Just wrap the call to the main function or main script with <code>tryCatchLog()</code>:</p>

<pre><code class="r">library(futile.logger)
library(tryCatchLog)

options(keep.source = TRUE)        # source code file name and line number tracking
options(&quot;tryCatchLog.write.error.dump.file&quot; = TRUE) # dump for post-mortem analysis

flog.appender(appender.file(&quot;my_app.log&quot;))  # to log into a file instead of console
flog.threshold(INFO)    # TRACE, DEBUG, INFO, WARN, ERROR, FATAL

tryCatchLog(source(&quot;your_main_script.R&quot;))
</code></pre>

<h2>Enabling source code references (file names and line numbers)</h2>

<p>To show <strong>file names and line numbers</strong> in the stack trace of the log output:</p>

<ul>
<li><p>For R script files</p>

<p>R does track source code references of scripts only if you set <code>options(keep.source = TRUE)</code> before.</p>

<p>If you use <code>Rscript</code> to start a non-interactive R script as batch job you
have to set this option since it is FALSE by default.</p>

<p>You can add this option to your <code>.Rprofile</code> file or use a startup R script as stub to set this option</p></li>
<li><p>For installed packages</p>

<p>By default, most packages are built without source reference information.
Setting the environment variable <code>R_KEEP_PKG_SOURCE=yes</code> before installing a source package
will tell R to keep the source references.</p>

<p>You can also use set <code>{options(keep.source.pkgs = TRUE)</code> before you install a package.</p></li>
</ul>

<h2>FAQ</h2>

<p>You can find a FAQ with best practices at:</p>

<p><a href="https://github.com/aryoda/tryCatchLog#faq">https://github.com/aryoda/tryCatchLog#faq</a></p>

<h1>Appendix</h1>

<h2>References</h2>

<p>Documentation of the <code>futile.logger</code> logging framework:<br/>
<a href="https://github.com/zatonovo/futile.logger">https://github.com/zatonovo/futile.logger</a></p>

<p>Download of these slides: <a href="https://github.com/aryoda/R_trainings">https://github.com/aryoda/R_trainings</a></p>

<p>Project home of the <code>tryCatchLog</code> package: <a href="https://github.com/aryoda/tryCatchLog">https://github.com/aryoda/tryCatchLog</a></p>

<p><a href="http://www.biostat.jhsph.edu/%7Erpeng/docs/R-debug-tools.pdf">http://www.biostat.jhsph.edu/~rpeng/docs/R-debug-tools.pdf</a></p>

<p><a href="https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Murdoch.pdf">https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Murdoch.pdf</a></p>

</body>

</html>
